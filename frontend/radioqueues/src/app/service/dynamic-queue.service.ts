import { Injectable, inject } from "@angular/core";
import { DatabaseService } from "./database.service";
import { SECONDS, MINUTES, HOURS } from "../model/time";

class Item {

	constructor(public name: string, public duration: number) { }
}

@Injectable({
	providedIn: 'root'
})
export class DynamicQueueService {
	private databaseService = inject(DatabaseService);

	public async scheduleQueue(queueTypeName: string, duration: number) {
		while (duration > 70 * MINUTES) {
			// TODO: for realy long duration, just pick long files, subset-sum is too expensive
			duration = duration - 1 * HOURS;
		}
		let list = await this.createList(queueTypeName);
		if (!list || !list.length) {
			console.error("Cannot find files for subset-sum queue type " + queueTypeName);
			return;
		}

		let result = this.pickMusicSubset(list, duration, 30 * SECONDS);
		if (!result.totalDuration) {
			result = this.pickMusicSubset(list, duration, 60 * SECONDS);
		}
		if (!result.totalDuration) {
			if (duration > 3 * MINUTES || list.length < 20) {
				console.log("unused:", list);
				list = await this.createList(queueTypeName);
				result = this.pickMusicSubset(list!, duration, 30 * SECONDS);
				if (!result.totalDuration) {
					result = this.pickMusicSubset(list!, duration, 60 * SECONDS);
				}
			}
		}

		if (result.indexes) {
			console.log(list!.length, (result.totalDuration - duration) / SECONDS, result);
			return result.names;
		}


		// TODO: do something useful
		return undefined;
	}

	private async createList(queueTypeName: string) {
		let queueTypes = await this.databaseService.getQueueTypes();
		let queueType = queueTypes[queueTypeName];
		let folder = queueType?.folder;

		let files = await this.databaseService.getFiles();
		let list: Item[] = [];
		if (!folder?.endsWith("/")) {
			folder = folder + "/";
		}
		for (let filename in files) {
			let file = files[filename];
			if (filename.startsWith(folder) && file.duration && file.duration > 0) {
				list.push(new Item(filename, file.duration));
			}
		}
		return list;
	}



	private pickMusicSubset(musicFiles: Array<Item>, targetTime: number, tolerance: number) {
		// generated by ChatGPT with small adjustments
		// https://chatgpt.com/share/34e37503-2bdf-478d-a6c1-a364ae519870
		// 1. prompt: Please write a JavaScript program for me. I have a pool of music files with various durations.
		//            I want to pick a subset of music files so that the music plays for x minutes.
		// 2. prompt: This works perfectly correct. But it is too slow.
		// 3. prompt: It's still too slow. Any result that is within 10 seconds of the target duration is okay.

		// Sort the music files in descending order by duration
		musicFiles.sort((a, b) => b.duration - a.duration);

		let bestSubset: Array<number> = [];
		let bestDuration = 0;

		function backtrack(index: number, currentSubset: Array<number>, currentDuration: number) {
			// Early exit if within the acceptable margin
			if (Math.abs(currentDuration - targetTime) <= tolerance) {
				bestSubset = [...currentSubset];
				bestDuration = currentDuration;
				return true; // Found a close enough match
			}

			// If current duration exceeds target or if no more files are available, stop exploring
			if (currentDuration > targetTime || index === musicFiles.length) {
				return false;
			}

			// Try including the current file
			if (currentDuration + musicFiles[index].duration <= targetTime + tolerance) {
				currentSubset.push(index);
				if (backtrack(index + 1, currentSubset, currentDuration + musicFiles[index].duration)) {
					return true;
				}
				currentSubset.pop(); // Backtrack
			}

			// Try excluding the current file
			return backtrack(index + 1, currentSubset, currentDuration);
		}

		// Start the backtracking process
		backtrack(0, [], 0);
		let durations: Array<number> = [];
		let names: Array<string> = [];
		for (let i = 0; i < bestSubset.length; i++) {
			durations.push(musicFiles[bestSubset[i]].duration);
			names.push(musicFiles[bestSubset[i]].name);
		}

		return {
			totalDuration: bestDuration,
			indexes: bestSubset,
			files: durations,
			names: names
		};
	}

}